'use strict';
const crypto = require('crypto');

// Function is used to compare two strings and avoid timing attack, therefore it does not break on mismatch.
function secureCompare(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  const bufferA = Buffer.from(a, 'utf8');
  const bufferB = Buffer.from(b, 'utf8');
  return crypto.timingSafeEqual(bufferA, bufferB);
}

const states = {};
// eslint-disable-next-line no-unused-vars
module.exports = (req, res, next) =>{

  const {url, method , body , headers} = req;
  const secret =  headers['x-state-parameter-secret'];
  const routerConfig = req.app.get('mainRouterConfig');

  if (!secret || !secureCompare(secret, routerConfig.stateParameterSecret)){
    res.statusCode = 401;
    return res.end(JSON.stringify({error: 'Invalid secret value'}));
  }

  if (method === 'POST' && body && body.state){
    states[body.state] =  body.state;
    res.statusCode = 200;
    return res.end();
  }

  if (method === 'GET'){
    const parameter =  url.split('/').pop();
    if (!parameter){
      res.statusCode = 401;
      return res.end(JSON.stringify({error: 'State parameter not received from Authorization service'}));
    }
    if (!isValidUUIDv4(parameter)){
      res.statusCode = 400;
      return res.end(JSON.stringify({error: 'State parameter is not valid: ' + parameter}));
    }
    if (states[parameter]){
      delete states[parameter];
      res.statusCode = 200;
      return res.end();
    }
    res.statusCode = 401;
    return res.end(JSON.stringify({error: 'Invalid state parameter'}));
  }

  res.statusCode = 400;
  return res.end();
};

function isValidUUIDv4(uuid) {
  const uuidPattern = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
  return uuidPattern.test(uuid);
}
