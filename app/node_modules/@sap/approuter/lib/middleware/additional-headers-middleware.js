'use strict';

const _     = require('lodash');
const request     = require('../utils/request-utils');
const passportUtils  = require('../passport/utils');
const stdTTL = process.env.FRAME_ANCESTORS_CSP_HEADER_CACHE_TIME || 300;
const checkPeriod           = stdTTL + 20;
const NodeCache           = require('node-cache');
const cspHeadersCache      = new NodeCache({stdTTL: stdTTL, checkperiod: checkPeriod});
// eslint-disable-next-line no-undef
const tracer = require('../utils/logger').getTracer(__filename);
const X_FRAME_OPTIONS = 'x-frame-options';
const CSP_HEADER_NAME = 'Content-Security-Policy';

module.exports = async function additionalHeaders(req, res, next) {
  let routerConfig = req.routerConfig;

  let additionalHeaders = routerConfig.additionalHeaders.slice();

  additionalHeaders = modifyAdditionalHeadersFromResponseHeaders(req,additionalHeaders);

  if (routerConfig.sendXFrameOptions) {
    let xFrameHeader = _.find(additionalHeaders, function searchXFrame(header) { return !!header[X_FRAME_OPTIONS]; });
    if (!xFrameHeader) {
      res.setHeader(X_FRAME_OPTIONS, 'SAMEORIGIN');
    }
  }
  additionalHeaders.forEach(function addAdditionalHeader(header) {
    try {
      _.forEach(header, function setHeader(value, name) {
        let currentValue = res.getHeader(name);
        if (currentValue === undefined) {
          res.setHeader(name, value);
        } else if (Array.isArray(currentValue)) {
          currentValue.push(value);
        } else { // string
          res.setHeader(name, [currentValue, value]);
        }
      });
    } catch (err) {
      return next(err);
    }
  });
  try {
    await module.exports.getCSPFrameAncestorsFromSubaccount(req, res, routerConfig);
  } catch (err){
    return next(err);
  }
  next();
};

function getLandscapeDomain(cfApiUrl) {
  let url = new URL(cfApiUrl);
  let parts = url.hostname.split('.');
  parts.shift(); // remove 'api'
  parts.shift(); // remove 'cf'
  return parts.join('.');
}

module.exports.getCSPFrameAncestorsFromSubaccount = async function getCSPFrameAncestorsFromSubaccount(req, res, routerConfig) {
  if (routerConfig.enableCSPheaders) {
    let subdomain = passportUtils.getTenantInfo(req).tenant;
    if (!subdomain) {
      return;
    }
    let apiURL;
    const btpTenantAPI = (routerConfig.iasConfig && routerConfig.iasConfig.options && routerConfig.iasConfig.options['btp-tenant-api']) ||
      (routerConfig.uaaConfig && routerConfig.uaaConfig.options && routerConfig.uaaConfig.options['apiurl']);

    if (btpTenantAPI) {
      apiURL = `${btpTenantAPI}/sap/rest/authorization/v2/securitySettings/public?subdomain=${subdomain}`;
    } else {
      const landscapeDomain = getLandscapeDomain(JSON.parse(process.env.VCAP_APPLICATION).cf_api);
      if (!landscapeDomain) {
        return;
      }
      apiURL = `https://api.authentication.${landscapeDomain}/sap/rest/authorization/v2/securitySettings/public?subdomain=${subdomain}`;
    }
    // Check if cspHeaders are cached
    const cachedCSPHeaders = cspHeadersCache.get(subdomain);
    if (cachedCSPHeaders) {
      res.setHeader(CSP_HEADER_NAME, cachedCSPHeaders);
    } else {
      let result = await request.axiosRequest('get',{url: apiURL});
      if (result.error || result.response.statusCode !== 200){
        throw new Error('Failed to fetch allowed domains from xsuaa ' + result.error
            + (result.response && result.response.statusCode ? `response status ${result.response.statusCode}` : ''));
      }
      const resultBody = result.body && JSON.parse(result.body);
      if (resultBody && resultBody.iframeDomains) {
        const cspHeaders = `frame-ancestors ${resultBody.iframeDomains};`;
        cspHeadersCache.set(subdomain, cspHeaders);
        res.setHeader(CSP_HEADER_NAME, cspHeaders);
      }
    }
  }
};

module.exports.clearCache = function() {
  if (cspHeadersCache) {
    cspHeadersCache.flushAll();
  }
};

function modifyAdditionalHeadersFromResponseHeaders(req, additionalHeaders) {
  let foundIndex;

  if (!req.routerConfig.appConfig.responseHeaders){
    return additionalHeaders;
  }

  req.routerConfig.appConfig.responseHeaders.forEach(function (responseHeader) {
    foundIndex = -1;

    for (let i = 0; i < additionalHeaders.length; i++) {
      if (additionalHeaders[i].hasOwnProperty(responseHeader.name.toLowerCase())) {
        foundIndex = i;
        break;
      }
    }

    if (foundIndex > -1) {
      additionalHeaders[foundIndex] = {
        [responseHeader.name]: responseHeader.value
      };
      tracer.debug('found response header name %s in additional headers, so update response header value %s instead of previous value', responseHeader.name, responseHeader.value);
    }
    else {
      additionalHeaders.push({
        [responseHeader.name]: responseHeader.value
      });
    }

  });

  return additionalHeaders;
}
