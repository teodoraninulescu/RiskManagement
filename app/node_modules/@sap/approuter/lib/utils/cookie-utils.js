'use strict';

const crypto = require('crypto');
const querystring = require('querystring');
const tough = require('tough-cookie');
const uaaUtils = require('./uaa-utils');
const pathUtil = require('./path-util');
const iasUtils = require('./ias-utils');

const SESSION_SECRET_LENGTH = 64;

exports.generateSessionSecret = function () {
  return crypto.randomBytes(SESSION_SECRET_LENGTH).toString('hex');
};

exports.getBackendCookiesSecret = function () {
  return process.env.BACKEND_COOKIES_SECRET || exports.generateSessionSecret();
};

exports.getExternalStoreSessionSecret = function (extSessionMgt) {
  return extSessionMgt && extSessionMgt.sessionSecret;
};

const resizedIV = Buffer.allocUnsafe(16);
const iv = crypto
  .createHash('sha256')
  .update(exports.getBackendCookiesSecret())
  .digest();
iv.copy(resizedIV);
const key = crypto
  .createHash('sha256')
  .update(exports.getBackendCookiesSecret())
  .digest();

exports.setCookie = function (res, cookie) {
  const oldCookies = res.getHeader('set-cookie');
  res.setHeader('set-cookie', oldCookies ? [].concat(oldCookies, cookie) : cookie);
};

exports.getSessionCookieName = function () {
  // This cookie name 'JSESSIONID' tells Cloud Foundry to use session stickiness
  // https://docs.cloudfoundry.org/devguide/deploy-apps/prepare-to-deploy.html#sessions
  // https://github.com/cloudfoundry/gorouter/issues/26
  return getCookieName('AR-', 'JSESSIONID');
};

exports.getRedirectLocationCookieName = function () {
  return getCookieName('ARLOC-', 'locationAfterLogin');
};

exports.getFragmentCookieName = function () {
  return getCookieName('ARFRG-', 'fragmentAfterLogin');
};

exports.getBackendCookieName = function () {
  return getCookieName('ARBE-', 'ARBE');
};

function getCookieName(prefix, defaultCookieName) {
  if ('USE_JSESSION_COOKIE_SUFFIX_REQUIRED' in process.env && process.env.VCAP_APPLICATION) {
    // With port based routing the session cookies of two app router applications may
    // overwrite/reuse each other if the browser ignores the port of the applications
    const vcapApplication = JSON.parse(process.env.VCAP_APPLICATION);
    if (vcapApplication.application_id) {
      return prefix + compactGuid(vcapApplication.application_id);
    }
  }
  return defaultCookieName;
}

function compactGuid(guid) {
  return guid.split('-').map(function (segment) {
    return parseInt(segment, 16).toString(36);
  }).join('');
}

exports.signCookie = function (req, value, cb) {
  if (req && pathUtil.pathAuthenticationType(req) === 'ias' && iasUtils.getIasCredentials(req)) {
    iasUtils.getIasConfig(req, function (err, iasOptions) {
      if (err) {
        return cb(err);
      }
      return encrypt(value, iasOptions, cb);
    });
  } else {
    uaaUtils.getUaaConfig(req, function (err, uaaOptions) {
      if (err) {
        return cb(err);
      }
      return encrypt(value, uaaOptions, cb);
    });
  }
};

exports.verifyCookie = function (req, value, signature, cb) {
  exports.signCookie(req, value, function (err, hash) {
    if (err) {
      return cb(err);
    }
    if (signature && signature.includes(hash)) {
      cb();
    } else {
      cb('Signature does not match');
    }
  });
};

// See: https://nodejs.org/en/knowledge/cryptography/how-to-use-crypto-module/
exports.encryptCookies = function (cookies, backendName) {
  const msg = [];
  const cipher = crypto.createCipheriv('aes256', key, resizedIV);
  msg.push(cipher.update(JSON.stringify({[backendName]: cookies.map(cookie => cookie.key + '=' + cookie.value)}), 'binary', 'hex'));
  msg.push(cipher.final('hex'));
  return exports.getBackendCookieName() + '=' + msg.join('') + '; Path=/; HttpOnly;';
};

exports.decryptCookies = function (cookies, backendName, logger) {
  logger && logger.info('Cookies %s are decrypted for backendName %s', cookies, backendName);
  let idx = -1;
  const msg = [];
  const backendCookieName = exports.getBackendCookieName();
  const splitCookies = cookies.split(';');
  const parsedCookies = splitCookies.map(cookie => tough.Cookie.parse(cookie));
  const encryptedCookie = parsedCookies.find((cookie, i) => (cookie.key === backendCookieName) && (idx = i) >= 0);
  if (encryptedCookie) {
    parsedCookies.splice(idx, 1);
    try {
      const decipher = crypto.createDecipheriv('aes256', key, resizedIV);
      msg.push(decipher.update(encryptedCookie.value, 'hex', 'binary'));
      msg.push(decipher.final('binary'));
    } catch (err) {
      logger && logger.info('Failed to decrypt cookie with key %s and value %s', encryptedCookie.key, encryptedCookie.value);
      return parsedCookies.join(';');
    }
    const messageValToJson = JSON.parse(msg.join(''));
    if (!messageValToJson[backendName]){
      const arbeBackendName = Object.keys(messageValToJson)[0];
      logger && logger.info('Backend %s not found in ARBE cookie which belongs to backend %s ', backendName, arbeBackendName);
    }
    else {
      const reducedValue = messageValToJson[backendName].reduce(onReduce, []);
      const itemToPush = reducedValue.join('; ');
      parsedCookies.push(itemToPush);
    }
    return parsedCookies.join(';');
  } else {
    return cookies;
  }
};

exports.getBackendName = function (req) {
  return req && req.internalUrl && req.internalUrl.route &&
    (req.internalUrl.route.destination || req.internalUrl.route.service);
};

exports.addSamesite = function (cookie, sameSite) {
  if (sameSite) {
    let sameSiteString = ';Secure;SameSite=' + sameSite + ';";';
    cookie = cookie.endsWith('";') ? cookie.slice(0, -2) + sameSiteString : cookie + sameSiteString.slice(0, -2);
  }
  return cookie;
};

exports.addAttributes = function (cookie, req) {
  const attrs = [];
  const opts = Object.assign({}, req.routerConfig && req.routerConfig.cookies);
  if (opts.Partitioned) {
    const userAgent = req.headers['user-agent'] || '';
    opts.supportedPartitionAgents = userAgent.match(opts.Partitioned.supportedPartitionAgents);
    opts.unsupportedPartitionAgents = userAgent.match(opts.Partitioned.unsupportedPartitionAgents);
  }
  const partitionedAllowed = opts.supportedPartitionAgents && !opts.unsupportedPartitionAgents;
  if (opts.SameSite === 'None' || partitionedAllowed) {
    cookie = cookie.replaceAll(/;\s*Secure\s*(;|$)/gi, ';');
    attrs.push('Secure');
  }
  if (opts.SameSite) {
    cookie = cookie.replaceAll(/;\s*SameSite\s*=\s*[^;]*(;|$)/gi, ';');
    attrs.push('SameSite=' + opts.SameSite);
  }
  if (partitionedAllowed){
    cookie = cookie.replaceAll(/;\s*Partitioned\s*(;|$)/gi, ';');
    attrs.push('Partitioned');
  }
  const endsWithSemicolon = /;\s*$/.test(cookie);
  const quoted = cookie.match(/"\s*;\s*$/);
  return (quoted ? cookie.slice(0, -quoted[0].length) : cookie) + (endsWithSemicolon && !quoted ? '' : ';') + attrs.join(';') + (quoted ? '";' : '');
};

function encrypt(value, options, cb) {
  if (!options || (!options.clientsecret && !options.clientid)) {
    return cb('Invalid UAA options');
  }
  const encryptionKey = options.clientsecret || options.clientid;
  const hash = crypto
    .createHash('sha1')
    .update(value + '-' + encryptionKey, 'ascii')
    .digest('base64');
  return cb(null, querystring.escape(hash));
}

function onReduce (allCookies, cookie){
  let parsedCookie = tough.Cookie.parse(cookie);
  if (parsedCookie) {
    const {key, value} = parsedCookie;
    allCookies.push(key + '=' + value);
  }
  return allCookies;
}
